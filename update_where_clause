from thefuzz import process
from typing import Dict, List, Tuple, Any, Union

def get_closest_match(value: str, valid_values_lower: Dict[str, str],
                      threshold: int = 98) -> Tuple[Union[str, List[str]], float]:
    """
    Find closest match(es) using lowercase comparison
    Returns multiple matches if they have the same highest score

    Args:
        value: The value to match
        valid_values_lower: Mapping of lowercase values to original case
        threshold: Minimum similarity score (0-100) to consider a match

    Returns:
        Tuple containing:
        - Either a single matched value or list of matched values if multiple matches have same score
        - Match score
    """
    # Get all matches with scores
    matches = process.extract(value.lower(), valid_values_lower.keys())

    # Get highest score
    highest_score = matches[0][1]

    # Get all matches with the highest score
    best_matches = [valid_values_lower[match[0]] for match in matches if match[1] == highest_score]

    # If score meets threshold, return match(es)
    if highest_score >= threshold:
        return (best_matches[0] if len(best_matches) == 1 else best_matches, highest_score)
    return value, highest_score

def update_values_in_clause(
        where_clause: Dict[str, Any],
        target_key: str,
        valid_values: List[str],
        threshold: int = 80
) -> Tuple[Dict[str, Any], List[Tuple[str, Union[str, List[str]], float]]]:
    """
    Recursively updates specified key's values in a where clause with closest matching values

    Args:
        where_clause: The where clause dictionary to update
        target_key: The key whose values need to be corrected
        valid_values: List of valid values in their original case
        threshold: Minimum similarity score for fuzzy matching

    Returns:
        Tuple containing:
        - Updated where clause (with ambiguous matches as lists)
        - List of replacements made (original_value, corrected_value(s), score)
    """
    OPERATORS = {'$eq', '$ne', '$gt', '$gte', '$lt', '$lte', '$in', '$nin'}
    valid_values_lower = {val.lower(): val for val in valid_values}
    replacements = []

    def _recursive_update(clause):
        if not isinstance(clause, dict):
            return clause

        updated_clause = {}
        for key, value in clause.items():
            if key == target_key:
                if isinstance(value, dict) and any(op in value for op in OPERATORS):
                    # Handle operator cases
                    updated_clause[key] = {}
                    for op, op_value in value.items():
                        if op in ['$in', '$nin']:
                            # Handle array operators
                            if isinstance(op_value, list):
                                corrected_values = []
                                for val in op_value:
                                    if isinstance(val, str):
                                        corrected_val, score = get_closest_match(val, valid_values_lower, threshold)
                                        if corrected_val != val:
                                            replacements.append((val, corrected_val, score))
                                        corrected_values.append(corrected_val)
                                    else:
                                        corrected_values.append(val)
                                updated_clause[key][op] = corrected_values
                            else:
                                # Handle case where $in/$nin value is not a list
                                updated_clause[key][op] = op_value
                        elif isinstance(op_value, str):
                            corrected_value, score = get_closest_match(op_value, valid_values_lower, threshold)
                            if corrected_value != op_value:
                                replacements.append((op_value, corrected_value, score))
                            updated_clause[key][op] = corrected_value
                        else:
                            updated_clause[key][op] = op_value
                elif isinstance(value, list):
                    corrected_values = []
                    for val in value:
                        if isinstance(val, str):
                            corrected_val, score = get_closest_match(val, valid_values_lower, threshold)
                            if corrected_val != val:
                                replacements.append((val, corrected_val, score))
                            corrected_values.append(corrected_val)
                        else:
                            corrected_values.append(val)
                    updated_clause[key] = corrected_values
                elif isinstance(value, str):
                    corrected_value, score = get_closest_match(value, valid_values_lower, threshold)
                    if corrected_value != value:
                        replacements.append((value, corrected_value, score))
                    updated_clause[key] = corrected_value
                else:
                    updated_clause[key] = value
            elif isinstance(value, dict):
                updated_clause[key] = _recursive_update(value)
            elif isinstance(value, list):
                updated_clause[key] = [
                    _recursive_update(item) if isinstance(item, dict)
                    else item
                    for item in value
                ]
            else:
                updated_clause[key] = value

        return updated_clause

    updated_where_clause = _recursive_update(where_clause)
    return updated_where_clause, replacements

# Example usage with $in and $nin operators:
valid_categories = ["Network Support", "Network Security", "Network Services", "Tablet"]
where_clause = {
    "$or": [
        {"category": {"$in": ["network", "tab"]}},
        {"$and": [
            {"category": {"$nin": ["support", "security"]}},
            {"price": {"$lt": 1000}}
        ]}
    ]
}

corrected_clause, replacements = update_values_in_clause(
    where_clause, "category", valid_categories, threshold=90
)

print("\nReplacements made:")
for original, corrected, score in replacements:
    if isinstance(corrected, list):
        print(f"'{original}' -> Multiple matches with score {score}:")
        for match in corrected:
            print(f"  - '{match}'")
    else:
        print(f"'{original}' -> '{corrected}' (score: {score})")

print("\nCorrected where clause:")
print(corrected_clause)
